#!/usr/bin/env python3
"""
Temporal Database Initialization Script for Generated Projects

This script initializes the temporal database for VibesPro-generated projects,
setting up the necessary tables and initial data.
"""

import asyncio
import sys
import argparse
from pathlib import Path
from datetime import datetime, timezone
import json

# Add the temporal_db module to path (assuming it's copied to the project)
project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))

try:
    from temporal_db.python.repository import initialize_temporal_database
    from temporal_db.python.types import (
        SpecificationRecord,
        ArchitecturalPattern,
        SpecificationType,
        PatternType
    )
except ImportError:
    print("❌ Temporal database module not found. Please ensure the temporal_db package is available.")
    sys.exit(1)


async def init_database(db_path: str, project_name: str) -> None:
    """Initialize the temporal database with project-specific data."""
    print(f"🔗 Initializing temporal database at: {db_path}")

    try:
        # Initialize the database
        repo = await initialize_temporal_database(db_path)

        # Create initial project specification
        project_spec = SpecificationRecord.create(
            spec_type=SpecificationType.ADR,
            identifier="ADR-PROJECT-001",
            title="Project Architecture Foundation",
            content=f"""# Project Architecture Foundation

This document establishes the architectural foundation for the {project_name} project.

## Decision

We adopt a hexagonal architecture (ports and adapters) pattern combined with Domain-Driven Design (DDD) principles.

## Status

Accepted
""",
            author="VibesPro Generator",
        )

        await repo.store_specification(project_spec)
        await repo.close()

        print("✅ Temporal database initialized successfully")

    except Exception as e:
        print(f"❌ Database initialization failed: {e}")
        sys.exit(1)


async def status_database(db_path: str) -> None:
    """Show status of the temporal database."""
    print(f"📊 Checking temporal database status: {db_path}")

    try:
        repo = await initialize_temporal_database(db_path)

        # Get some basic statistics
        patterns = await repo.get_similar_patterns("", 0.0, 365)
        decision_patterns = await repo.analyze_decision_patterns(365)

        await repo.close()

        print("✅ Database connection successful")
        print(f"   🏗️  Architectural patterns: {len(patterns)}")
        print(f"   🎯 Decision patterns: {len(decision_patterns)}")

    except Exception as e:
        print(f"❌ Database status check failed: {e}")
        sys.exit(1)


async def backup_database(db_path: str, backup_path: str) -> None:
    """Create a backup of the temporal database."""
    print(f"💾 Creating backup: {db_path} → {backup_path}")

    try:
        import shutil
        shutil.copy2(db_path, backup_path)
        print("✅ Backup created successfully")

    except Exception as e:
        print(f"❌ Backup failed: {e}")
        sys.exit(1)


def main():
    """Main CLI interface for temporal database management."""
    parser = argparse.ArgumentParser(description="VibesPro Temporal Database Management")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Init command
    init_parser = subparsers.add_parser("init", help="Initialize temporal database")
    init_parser.add_argument("--db-path", default="./temporal_db/project_specs.db",
                           help="Database file path")
    init_parser.add_argument("--project-name", default="{{ project_name }}",
                           help="Project name for initialization")

    # Status command
    status_parser = subparsers.add_parser("status", help="Check database status")
    status_parser.add_argument("--db-path", default="./temporal_db/project_specs.db",
                             help="Database file path")

    # Backup command
    backup_parser = subparsers.add_parser("backup", help="Backup database")
    backup_parser.add_argument("--db-path", default="./temporal_db/project_specs.db",
                             help="Database file path")
    backup_parser.add_argument("--backup-path",
                             default=f"./temporal_db/backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}.db",
                             help="Backup file path")

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return

    if args.command == "init":
        asyncio.run(init_database(args.db_path, args.project_name))
    elif args.command == "status":
        asyncio.run(status_database(args.db_path))
    elif args.command == "backup":
        asyncio.run(backup_database(args.db_path, args.backup_path))


if __name__ == "__main__":
    main()
