default:
	@echo "Available recipes: plan-techstack [ts=techstack.yaml], sync-techstack [ts=techstack.yaml], sync-techstack-dry [ts=techstack.yaml]"

# Preview changes to the resolved tech stack (diff only)
plan-techstack ts="techstack.yaml":
	bash scripts/plan_techstack.sh {{ '{{ts}}' }}

# Apply changes to the resolved tech stack (writes .derived JSON)
sync-techstack ts="techstack.yaml":
	bash scripts/sync_techstack.sh {{ '{{ts}}' }}

# Apply (dry-run): no writes, show diff
sync-techstack-dry ts="techstack.yaml":
	bash scripts/sync_techstack.sh --dry-run {{ '{{ts}}' }}

# Linting and Testing
lint-shell:
	pnpm lint:shell

# Lint prompts for compliance with standards
prompt-lint:
	pnpm prompt:lint

# Generate traceability matrix for specifications
spec-matrix:
	pnpm spec:matrix

# --- Spec-Driven Workflow Recipes ---

# Scaffold a feature specification
spec-feature THREAD="":
	@if [ -z "{{ '{{THREAD}}' }}" ]; then \
		echo "Usage: just spec-feature THREAD=<feature-slug>"; \
		echo "Example: just spec-feature THREAD=test-feature"; \
		exit 1; \
	fi
	@mkdir -p "docs/specs/{{ '{{THREAD}}' }}"
	@echo "---" > "docs/specs/{{ '{{THREAD}}' }}/spec.md"
	@echo "thread: {{ '{{THREAD}}' }}" >> "docs/specs/{{ '{{THREAD}}' }}/spec.md"
	@echo "matrix_ids: []" >> "docs/specs/{{ '{{THREAD}}' }}/spec.md"
	@echo "" >> "docs/specs/{{ '{{THREAD}}' }}/spec.md"
	@echo "# Feature Specification" >> "docs/specs/{{ '{{THREAD}}' }}/spec.md"
	@echo "" >> "docs/specs/{{ '{{THREAD}}' }}/spec.md"
	@echo "## What" >> "docs/specs/{{ '{{THREAD}}' }}/spec.md"
	@echo "" >> "docs/specs/{{ '{{THREAD}}' }}/spec.md"
	@echo "## Why" >> "docs/specs/{{ '{{THREAD}}' }}/spec.md"
	@echo "" >> "docs/specs/{{ '{{THREAD}}' }}/spec.md"
	@echo "Created feature specification for thread: {{ '{{THREAD}}' }}"

# Generate detailed implementation plan from feature spec
spec-plan THREAD="" FAMILY="":
	@if [ -z "{{ '{{THREAD}}' }}" ]; then \
		echo "Usage: just spec-plan THREAD=<feature-slug> FAMILY=<adr|prd|sds|ts|task>"; \
		echo "Example: just spec-plan THREAD=test-feature FAMILY=prd"; \
		exit 1; \
	fi
	@if ! echo "{{ '{{FAMILY}}' }}" | grep -qE "^(adr|prd|sds|ts|task)$$"; then \
		echo "Error: FAMILY must be one of: adr, prd, sds, ts, task"; \
		exit 1; \
	fi
	@mkdir -p "docs/specs/{{ '{{THREAD}}' }}"
	@echo "---" > "docs/specs/{{ '{{THREAD}}' }}/plan.{{ '{{FAMILY}}' }}.md"
	@echo "thread: {{ '{{THREAD}}' }}" >> "docs/specs/{{ '{{THREAD}}' }}/plan.{{ '{{FAMILY}}' }}.md"
	@echo "matrix_ids: []" >> "docs/specs/{{ '{{THREAD}}' }}/plan.{{ '{{FAMILY}}' }}.md"
	@echo "" >> "docs/specs/{{ '{{THREAD}}' }}/plan.{{ '{{FAMILY}}' }}.md"
	@echo "# $(echo {{ '{{FAMILY}}' }} | tr '[:lower:]' '[:upper:]') Implementation Plan" >> "docs/specs/{{ '{{THREAD}}' }}/plan.{{ '{{FAMILY}}' }}.md"
	@echo "" >> "docs/specs/{{ '{{THREAD}}' }}/plan.{{ '{{FAMILY}}' }}.md"
	@echo "## TDD Cycles" >> "docs/specs/{{ '{{THREAD}}' }}/plan.{{ '{{FAMILY}}' }}.md"
	@echo "" >> "docs/specs/{{ '{{THREAD}}' }}/plan.{{ '{{FAMILY}}' }}.md"
	@echo "## File Changes" >> "docs/specs/{{ '{{THREAD}}' }}/plan.{{ '{{FAMILY}}' }}.md"
	@echo "" >> "docs/specs/{{ '{{THREAD}}' }}/plan.{{ '{{FAMILY}}' }}.md"
	@echo "## Validation Steps" >> "docs/specs/{{ '{{THREAD}}' }}/plan.{{ '{{FAMILY}}' }}.md"
	@echo "" >> "docs/specs/{{ '{{THREAD}}' }}/plan.{{ '{{FAMILY}}' }}.md"
	@echo "Created $(echo {{ '{{FAMILY}}' }} | tr '[:lower:]' '[:upper:]') implementation plan for thread: {{ '{{THREAD}}' }}"

# Create numbered list of discrete, executable tasks from the plan
spec-tasks THREAD="":
	@if [ -z "{{ '{{THREAD}}' }}" ]; then \
		echo "Usage: just spec-tasks THREAD=<feature-slug>"; \
		echo "Example: just spec-tasks THREAD=test-feature"; \
		exit 1; \
	fi
	@mkdir -p "docs/specs/{{ '{{THREAD}}' }}"
	@echo "---" > "docs/specs/{{ '{{THREAD}}' }}/tasks.md"
	@echo "thread: {{ '{{THREAD}}' }}" >> "docs/specs/{{ '{{THREAD}}' }}/tasks.md"
	@echo "matrix_ids: []" >> "docs/specs/{{ '{{THREAD}}' }}/tasks.md"
	@echo "" >> "docs/specs/{{ '{{THREAD}}' }}/tasks.md"
	@echo "# Tasks" >> "docs/specs/{{ '{{THREAD}}' }}/tasks.md"
	@echo "" >> "docs/specs/{{ '{{THREAD}}' }}/tasks.md"
	@echo "## Tasks" >> "docs/specs/{{ '{{THREAD}}' }}/tasks.md"
	@echo "" >> "docs/specs/{{ '{{THREAD}}' }}/tasks.md"
	@echo "1. [ ] Define the scope and objectives" >> "docs/specs/{{ '{{THREAD}}' }}/tasks.md"
	@echo "2. [ ] Identify key stakeholders and requirements" >> "docs/specs/{{ '{{THREAD}}' }}/tasks.md"
	@echo "3. [ ] Create implementation plan" >> "docs/specs/{{ '{{THREAD}}' }}/tasks.md"
	@echo "4. [ ] Execute tasks using TDD" >> "docs/specs/{{ '{{THREAD}}' }}/tasks.md"
	@echo "5. [ ] Validate and test the implementation" >> "docs/specs/{{ '{{THREAD}}' }}/tasks.md"
	@echo "" >> "docs/specs/{{ '{{THREAD}}' }}/tasks.md"
	@echo "Created task list for thread: {{ '{{THREAD}}' }}"

# --- AI-assisted workflows (additive, namespaced) ---


# Bundle AI context for Copilot chat modes
ai-context-bundle:
	bash scripts/bundle-context.sh docs/ai_context_bundle

# TDD phases

# New naming (tdd.*) ‚Äî legacy ai-* retained for familiarity in messages
tdd-red:
	@echo "Red Phase: write failing tests from specs."
	@echo "Open chat mode: tdd.red and reference docs/ai_context_bundle."

tdd-green:
	@echo "Green Phase: implement minimal code to pass tests."
	@echo "Open chat mode: tdd.green and reference docs/ai_context_bundle."

tdd-refactor:
	@echo "Refactor Phase: improve design while keeping tests green."
	@echo "Open chat mode: tdd.refactor and reference docs/ai_context_bundle."

# Debug phases
debug-start:
	@echo "Debug Start: normalize bug report and plan reproduction."
	@echo "Open chat mode: debug.start and reference docs/ai_context_bundle."

debug-repro:
	@echo "Debug Repro: write failing test to reproduce the issue."
	@echo "Open chat mode: debug.repro and reference docs/ai_context_bundle."

debug-isolate:
	@echo "Debug Isolate: narrow root cause using diffs/instrumentation."
	@echo "Open chat mode: debug.isolate and reference docs/ai_context_bundle."

debug-fix:
	@echo "Debug Fix: apply minimal change to make tests pass."
	@echo "Open chat mode: debug.fix and reference docs/ai_context_bundle."

debug-refactor:
	@echo "Debug Refactor: clean up the fix and remove instrumentation."
	@echo "Open chat mode: debug.refactor and reference docs/ai_context_bundle."

debug-regress:
	@echo "Debug Regress: run full regression to ensure stability."
	@echo "Open chat mode: debug.regress and reference docs/ai_context_bundle."

# Validate with existing repo tooling (safe-noop if pnpm/Nx absent)
ai-validate:
	@if command -v pnpm > /dev/null 2>&1; then \
		if [ -f package.json ] && grep -q '"lint"' package.json; then \
			pnpm run lint || true; \
		else \
			echo "No 'lint' script found in package.json. Skipping lint."; \
		fi; \
		if [ -f package.json ] && grep -q '"typecheck"' package.json; then \
			pnpm run typecheck || true; \
		else \
			echo "No 'typecheck' script found in package.json. Skipping typecheck."; \
		fi; \
		if pnpm exec nx --version > /dev/null 2>&1; then \
			pnpm exec nx run-many --target=test --all || true; \
		else \
			echo "Nx not available or no projects to test."; \
		fi; \
	else \
		echo "pnpm not found. Skipping lint/typecheck/test."; \
	fi

# Thin wrapper for Nx generate (prints guidance if pnpm missing)
ai-scaffold name="":
	@if [ -z "{{ '{{name}}' }}" ]; then \
		echo "Usage: just ai:scaffold name=<generator>"; \
		echo "Example: just ai:scaffold name=@nx/js:lib"; \
	else \
		if command -v pnpm > /dev/null 2>&1; then \
			echo "Running: pnpm exec nx g {{ '{{name}}' }}"; \
			pnpm exec nx g {{ '{{name}}' }}; \
		else \
			echo "pnpm not found. Please run: pnpm exec nx g {{ '{{name}}' }}"; \
		fi; \
	fi

# --- Temporal Database Management ---

# Initialize the temporal database for AI-enhanced workflows
db-init:
	@echo "üîó Initializing temporal database..."
	@python3 tools/temporal-db/init.py init --project-name="{{ project_name }}"

# Check temporal database status and statistics
db-status:
	@echo "üìä Checking temporal database status..."
	@python3 tools/temporal-db/init.py status

# Create a backup of the temporal database
db-backup:
	@echo "üíæ Creating temporal database backup..."
	@python3 tools/temporal-db/init.py backup

# Record an architectural decision in the temporal database
db-record-decision spec_id="" decision_point="" option="" context="" author="":
	@if [ -z "{{ '{{spec_id}}' }}" ] || [ -z "{{ '{{decision_point}}' }}" ] || [ -z "{{ '{{option}}' }}" ]; then \
		echo "Usage: just db-record-decision spec_id=<id> decision_point=<point> option=<selected> context=<context> author=<author>"; \
		echo "Example: just db-record-decision spec_id=ADR-001 decision_point=database_choice option=PostgreSQL context='Need ACID compliance' author=architect"; \
		exit 1; \
	fi
	@python3 -c "\
import asyncio; \
import sys; \
import traceback; \
sys.path.insert(0, 'tools/temporal-db'); \
from temporal_db.python.repository import initialize_temporal_database; \
async def record(): \
	   repo = None; \
	   try: \
	       repo = await initialize_temporal_database('./temporal_db/project_specs.db'); \
	       await repo.record_decision('{{ '{{spec_id}}' }}', '{{ '{{decision_point}}' }}', '{{ '{{option}}' }}', '{{ '{{context}}' }}', '{{ '{{author}}' }}' or 'user'); \
	       print('‚úÖ Decision recorded successfully'); \
	   except Exception as e: \
	       print(f'‚ùå Error recording decision: {{e}}', file=sys.stderr); \
	       traceback.print_exc(file=sys.stderr); \
	       sys.exit(1); \
	   finally: \
	       if repo is not None: \
	           try: \
	               await repo.close(); \
	           except Exception as e: \
	               print(f'‚ö†Ô∏è Warning: Error closing repository: {{e}}', file=sys.stderr); \
asyncio.run(record())"

# Store a new architectural pattern
db-store-pattern name="" type="" definition="":
	@if [ -z "{{ '{{name}}' }}" ] || [ -z "{{ '{{type}}' }}" ]; then \
		echo "Usage: just db-store-pattern name=<pattern_name> type=<Domain|Application|Infrastructure|Interface> definition=<json_definition>"; \
		echo "Example: just db-store-pattern name='CQRS Pattern' type=Application definition='{\"description\":\"Command Query Responsibility Segregation\"}'"; \
		exit 1; \
	fi
	@python3 -c "\
import asyncio; \
import sys; \
import json; \
import traceback; \
sys.path.insert(0, 'tools/temporal-db'); \
from temporal_db.python.repository import initialize_temporal_database; \
from temporal_db.python.types import ArchitecturalPattern, PatternType; \
async def store(): \
	   repo = None; \
	   try: \
	       repo = await initialize_temporal_database('./temporal_db/project_specs.db'); \
	       pattern = ArchitecturalPattern.create('{{ '{{name}}' }}', PatternType.{{ '{{type}}' }}, json.loads('{{ '{{definition}}' }}' or '{}')); \
	       await repo.store_architectural_pattern(pattern); \
	       print('‚úÖ Pattern stored successfully'); \
	   except Exception as e: \
	       print(f'‚ùå Error storing pattern: {{e}}', file=sys.stderr); \
	       traceback.print_exc(file=sys.stderr); \
	       sys.exit(1); \
	   finally: \
	       if repo is not None: \
	           try: \
	               await repo.close(); \
	           except Exception as e: \
	               print(f'‚ö†Ô∏è Warning: Error closing repository: {{e}}', file=sys.stderr); \
asyncio.run(store())"

# Query similar architectural patterns
db-query-patterns context="" threshold="0.5" days="90":
	@echo "üîç Querying architectural patterns..."
	@python3 -c "\
import asyncio; \
import sys; \
import traceback; \
sys.path.insert(0, 'tools/temporal-db'); \
from temporal_db.python.repository import initialize_temporal_database; \
async def query(): \
	   repo = None; \
	   try: \
	       repo = await initialize_temporal_database('./temporal_db/project_specs.db'); \
	       patterns = await repo.get_similar_patterns('{{ '{{context}}' }}', float('{{ '{{threshold}}' }}'), int('{{ '{{days}}' }}')); \
	       print(f'Found {len(patterns)} matching patterns:'); \
	       for p in patterns[:5]: \
	           print(f'  ‚Ä¢ {p.pattern_name} ({p.pattern_type.value}) - Used {p.usage_frequency} times'); \
	   except Exception as e: \
	       print(f'‚ùå Error querying patterns: {{e}}', file=sys.stderr); \
	       traceback.print_exc(file=sys.stderr); \
	       sys.exit(1); \
	   finally: \
	       if repo is not None: \
	           try: \
	               await repo.close(); \
	           except Exception as e: \
	               print(f'‚ö†Ô∏è Warning: Error closing repository: {{e}}', file=sys.stderr); \
asyncio.run(query())"

# Analyze decision patterns over time
db-analyze-decisions days="90":
	@echo "üìà Analyzing decision patterns..."
	@python3 -c "\
import asyncio; \
import sys; \
import traceback; \
sys.path.insert(0, 'tools/temporal-db'); \
from temporal_db.python.repository import initialize_temporal_database; \
async def analyze(): \
	   repo = None; \
	   try: \
	       repo = await initialize_temporal_database('./temporal_db/project_specs.db'); \
	       patterns = await repo.analyze_decision_patterns(int('{{ '{{days}}' }}')); \
	       print(f'Decision patterns over last {{ '{{days}}' }} days:'); \
	       for p in patterns[:10]: \
	           print(f'  ‚Ä¢ {p.get(\"decision_point\", \"Unknown\")}: {p.get(\"total_decisions\", 0)} decisions ({p.get(\"selected_count\", 0)} high confidence)'); \
	   except Exception as e: \
	       print(f'‚ùå Error analyzing decisions: {{e}}', file=sys.stderr); \
	       traceback.print_exc(file=sys.stderr); \
	       sys.exit(1); \
	   finally: \
	       if repo is not None: \
	           try: \
	               await repo.close(); \
	           except Exception as e: \
	               print(f'‚ö†Ô∏è Warning: Error closing repository: {{e}}', file=sys.stderr); \
asyncio.run(analyze())"

# Clean up old entries from temporal database (optional maintenance)
db-cleanup days="365":
	@echo "üßπ Cleaning up temporal database (keeping last {{ '{{days}}' }} days)..."
	@echo "Note: This operation is not yet implemented - all data is preserved for learning purposes"
	@echo "To manually clean up, use: rm temporal_db/project_specs.db && just db-init"
