{% if include_ai_workflows %}
#!/usr/bin/env python3
"""
Temporal Database Initialization for {{ project_name }}

Initializes tsink time-series database for storing architectural decisions
and development patterns.
"""

import os
import sys
from pathlib import Path
from datetime import datetime
from dataclasses import dataclass
from typing import Optional

@dataclass(frozen=True, kw_only=True)
class SpecificationRecord:
    id: str
    spec_type: str
    content: str
    timestamp: datetime
    project_context: Optional[str] = None

class TemporalRepository:
    """Simple temporal database wrapper for project specifications."""

    def __init__(self, db_path: str):
        self.db_path = Path(db_path)
        self.db_path.mkdir(exist_ok=True)

    def init_database(self):
        """Initialize temporal database structure."""
        print(f"Initializing temporal database at {self.db_path}")

        # Create database files
        (self.db_path / "specifications.db").touch(exist_ok=True)
        (self.db_path / "patterns.db").touch(exist_ok=True)
        (self.db_path / "decisions.db").touch(exist_ok=True)

        # Create initial specification record
        init_record = SpecificationRecord(
            id="INIT-001",
            spec_type="SYSTEM",
            content=f"Temporal database initialized for {{ project_name }}",
            timestamp=datetime.utcnow(),
            project_context="{{ project_name }} - {{ architecture_style }} architecture"
        )

        self.store_specification(init_record)
        print("âœ… Temporal database initialized successfully")

    def store_specification(self, spec: SpecificationRecord) -> None:
        """Store a specification record in the temporal database."""
        # Simple file-based storage for now (would use tsink in production)
        spec_file = self.db_path / f"{spec.spec_type.lower()}_{spec.id}.txt"
        with open(spec_file, 'w') as f:
            f.write(f"ID: {spec.id}\n")
            f.write(f"Type: {spec.spec_type}\n")
            f.write(f"Timestamp: {spec.timestamp.isoformat()}\n")
            f.write(f"Context: {spec.project_context}\n")
            f.write(f"Content:\n{spec.content}\n")

    def get_latest_specification(self, spec_type: str, identifier: str) -> Optional[SpecificationRecord]:
        """Retrieve the latest specification of a given type and identifier."""
        spec_file = self.db_path / f"{spec_type.lower()}_{identifier}.txt"
        if not spec_file.exists():
            return None

        # Simple parsing (would use proper database in production)
        with open(spec_file, 'r') as f:
            lines = f.readlines()

        if len(lines) < 4:
            return None

        return SpecificationRecord(
            id=lines[0].split(': ', 1)[1].strip(),
            spec_type=lines[1].split(': ', 1)[1].strip(),
            timestamp=datetime.fromisoformat(lines[2].split(': ', 1)[1].strip()),
            project_context=lines[3].split(': ', 1)[1].strip(),
            content='\n'.join(lines[5:]).strip()
        )

def main():
    """Initialize temporal database for the project."""
    db_path = Path("temporal_db")

    repo = TemporalRepository(str(db_path))
    repo.init_database()

    print(f"Temporal database ready at: {db_path.absolute()}")

if __name__ == "__main__":
    main()
{% endif %}
