import * as fs from 'fs';
import { glob } from 'glob';
import { compile } from 'json-schema-to-typescript';
import * as path from 'path';

async function generateTypes(): Promise<void> {
  const cwd = process.cwd();
  // Look for schema.json in generator directories
  const pattern = 'generators/**/schema.json';

  console.log(`Searching for schemas matching: ${pattern}`);

  const files = await glob(pattern, {
    cwd,
    ignore: ['**/node_modules/**', '**/files/**'],
  });

  if (files.length === 0) {
    console.log('No schema.json files found.');
    return;
  }

  console.log(`Found ${files.length} schema(s).`);

  for (const file of files) {
    const absolutePath = path.resolve(cwd, file);
    const dirname = path.dirname(absolutePath);
    let schemaContent;

    try {
      schemaContent = JSON.parse(fs.readFileSync(absolutePath, 'utf-8'));
    } catch (e) {
      console.error(`Failed to parse JSON in ${file}:`, e);
      process.exit(1);
    }

    // Determine interface name from title or fallback to 'Options' (default for compile)
    // compile function typically uses the `title` in top level schema to name the interface.
    // If we pass a name as second arg, it uses that.
    const schemaTitle = (schemaContent.title as string | undefined) ?? 'Options';

    try {
      const ts = await compile(schemaContent, schemaTitle, {
        cwd: dirname,
        bannerComment:
          '/* eslint-disable */\n/**\n * This file was automatically generated by json-schema-to-typescript.\n * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,\n * and run json-schema-to-typescript to regenerate this file.\n */',
        style: {
          singleQuote: true,
        },
      });

      const outputPath = path.join(dirname, 'schema.d.ts');
      fs.writeFileSync(outputPath, ts);
      console.log(`Generated ${outputPath}`);
    } catch (error) {
      console.error(`Error generating types for ${file}:`, error);
      process.exit(1);
    }
  }
}

generateTypes().catch((err) => {
  console.error(err);
  process.exit(1);
});
