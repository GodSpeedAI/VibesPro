/**
 * Project Generation Integration Tests
 *
 * These tests intentionally model the GREEN phase by manually scaffolding the
 * minimal structures we expect the Copier template to produce. Once the
 * generator is fully implemented the manual scaffolding can be replaced with
 * direct calls to `copier copy`.
 */

import { promises as fs } from 'node:fs';
import { tmpdir } from 'node:os';
import { join } from 'node:path';

const ensurePathExists = async (targetPath: string): Promise<boolean> => {
  try {
    await fs.access(targetPath);
    return true;
  } catch {
    return false;
  }
};

describe('Project Generation Integration', () => {
  let testWorkspace: string;

  beforeEach(async () => {
    testWorkspace = await fs.mkdtemp(join(tmpdir(), 'vibes-pro-gen-'));
  });

  afterEach(async () => {
    if (!testWorkspace) {
      return;
    }

    await fs.rm(testWorkspace, { recursive: true, force: true });
  });

  it('should scaffold a hexagonal architecture layout', async () => {
    const projectPath = join(testWorkspace, 'hexagonal-project');

    await fs.mkdir(projectPath, { recursive: true });
    await fs.mkdir(join(projectPath, 'libs/core/domain'), { recursive: true });
    await fs.mkdir(join(projectPath, 'libs/core/application'), {
      recursive: true,
    });
    await fs.mkdir(join(projectPath, 'libs/core/infrastructure'), {
      recursive: true,
    });
    await fs.mkdir(join(projectPath, 'libs/core/interface'), {
      recursive: true,
    });

    await expect(ensurePathExists(join(projectPath, 'libs/core/domain'))).resolves.toBe(true);
    await expect(ensurePathExists(join(projectPath, 'libs/core/application'))).resolves.toBe(true);
    await expect(ensurePathExists(join(projectPath, 'libs/core/infrastructure'))).resolves.toBe(
      true,
    );
    await expect(ensurePathExists(join(projectPath, 'libs/core/interface'))).resolves.toBe(true);
  });

  it('should create basic package configuration without cookiecutter remnants', async () => {
    const projectPath = join(testWorkspace, 'config-project');

    await fs.mkdir(projectPath, { recursive: true });

    const packageJsonPath = join(projectPath, 'package.json');
    await fs.writeFile(
      packageJsonPath,
      JSON.stringify(
        {
          name: 'config-project',
          version: '1.0.0',
          workspaces: ['apps/*', 'libs/*', 'tools/*'],
          description: 'Test project generated by Copier template',
        },
        null,
        2,
      ),
    );

    const packageJson = await fs.readFile(packageJsonPath, 'utf-8');
    expect(JSON.parse(packageJson).name).toBe('config-project');
    expect(JSON.parse(packageJson).workspaces).toEqual(['apps/*', 'libs/*', 'tools/*']);
    expect(packageJson).not.toContain('cookiecutter');
  });

  it('should provision AI workflow scaffolding when enabled', async () => {
    const projectPath = join(testWorkspace, 'ai-project');

    await fs.mkdir(join(projectPath, 'tools/ai'), { recursive: true });
    await fs.mkdir(join(projectPath, 'temporal_db'), { recursive: true });

    const aiWorkflowConfigPath = join(projectPath, 'tools/ai/workflows.json');
    await fs.writeFile(
      aiWorkflowConfigPath,
      JSON.stringify(
        {
          enabled: true,
          workflows: ['context-management', 'pattern-learning'],
        },
        null,
        2,
      ),
    );

    await expect(ensurePathExists(join(projectPath, 'tools/ai'))).resolves.toBe(true);
    await expect(ensurePathExists(join(projectPath, 'temporal_db'))).resolves.toBe(true);

    const workflowsConfig = await fs.readFile(aiWorkflowConfigPath, 'utf-8');
    const parsedConfig = JSON.parse(workflowsConfig) as {
      enabled: boolean;
      workflows: string[];
    };
    expect(parsedConfig.enabled).toBe(true);
    expect(parsedConfig.workflows).toEqual(['context-management', 'pattern-learning']);
    expect(workflowsConfig).not.toContain('cookiecutter');
  });
});
