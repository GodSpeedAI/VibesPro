# Vector configuration for local observability pipeline.
# Ingests OTLP traffic (gRPC + HTTP) and prints spans/logs to stdout for now.

data_dir = "tmp/vector-data"

[api]
enabled = true
address = "127.0.0.1:8686"

[sources.otlp]
type = "opentelemetry"
use_otlp_decoding = true

  [sources.otlp.acknowledgements]

  [sources.otlp.grpc]
  address = "0.0.0.0:4317"

  [sources.otlp.http]
  address = "0.0.0.0:4318"
  headers = []

  [sources.otlp.http.keepalive]
  max_connection_age_secs = 300
  max_connection_age_jitter_factor = 0.1

[transforms.traces_sanitize]
type = "remap"
inputs = ["otlp.traces"]
files = [
  "tools/vector/macros.vrl",
  "tools/vector/traces_sanitize.vrl",
]

[sinks.dev_console]
inputs = ["traces_sanitize"]
target = "stdout"
type = "console"

[sinks.dev_console.encoding]
codec = "json"

[sinks.trace_file]
type = "file"
inputs = ["traces_sanitize"]
path = "tmp/vector-traces.log"

[sinks.trace_file.encoding]
codec = "json"

# OpenObserve OTLP HTTP sink for production trace storage and analytics
# Requires: OPENOBSERVE_URL and OPENOBSERVE_TOKEN environment variables
[sinks.openobserve]
type = "http"
inputs = ["traces_sanitize"]
uri = "${OPENOBSERVE_URL:-http://localhost:5080}/api/${OPENOBSERVE_ORG:-default}/v1/traces"
method = "post"

[sinks.openobserve.encoding]
codec = "json"

[sinks.openobserve.auth]
strategy = "basic"
user = "${OPENOBSERVE_USER:-root@example.com}"
password = "${OPENOBSERVE_TOKEN:-dummy-token-for-validation}"

[sinks.openobserve.request]
timeout_secs = 30
retry_attempts = 3

  [sinks.openobserve.request.headers]
  "Content-Type" = "application/json"

[sinks.null_metrics]
inputs = ["otlp.metrics"]
type = "blackhole"

[transforms.metrics_logfire_extract]
type = "remap"
inputs = ["otlp.metrics"]
source = '''
.metric_name = to_string(.name) ?? ""
if !starts_with(.metric_name, "logfire.") {
  abort
}

if exists(.resource) && exists(.resource.attributes."service.name") {
  .service = to_string(.resource.attributes."service.name") ?? "unknown"
} else {
  .service = "unknown"
}

if exists(.resource) && exists(.resource.attributes.environment) {
  .environment = to_string(.resource.attributes.environment) ?? "local"
} else if exists(.attributes) && exists(.attributes.environment) {
  .environment = to_string(.attributes.environment) ?? "local"
} else {
  .environment = "local"
}
'''

[transforms.metrics_logfire_enrich]
type = "remap"
inputs = ["metrics_logfire_extract"]
source = '''
.category = "logfire"
'''

[sinks.metrics_logfire_openobserve]
type = "http"
inputs = ["metrics_logfire_enrich"]
uri = "${OPENOBSERVE_URL:-http://localhost:5080}/api/${OPENOBSERVE_ORG:-default}/v1/logfire_metrics"
method = "post"

[sinks.metrics_logfire_openobserve.encoding]
codec = "json"

[sinks.metrics_logfire_openobserve.auth]
strategy = "basic"
user = "${OPENOBSERVE_USER:-root@example.com}"
password = "${OPENOBSERVE_TOKEN:-dummy-token-for-validation}"

[sinks.metrics_logfire_openobserve.request]
timeout_secs = 30
retry_attempts = 3

  [sinks.metrics_logfire_openobserve.request.headers]
  "Content-Type" = "application/json"

# --- Logs Pipeline ---
# Process OTLP logs with PII redaction, enrichment, and storage

[transforms.logs_redact_pii]
type = "remap"
inputs = ["otlp.logs"]
file = "tools/vector/macros.vrl"

[transforms.logs_logfire_normalize]
type = "remap"
inputs = ["logs_redact_pii"]
source = '''
# Ensure trace correlation metadata is present for Logfire-generated logs
if !exists(.trace_id) {
  if exists(.attributes.trace_id) {
    trace_candidate = to_string(.attributes.trace_id) ?? ""
    if trace_candidate != "" { .trace_id = downcase(trace_candidate) }
  } else if exists(.attributes."logfire.trace_id") {
    trace_candidate = to_string(.attributes."logfire.trace_id") ?? ""
    if trace_candidate != "" { .trace_id = downcase(trace_candidate) }
  } else if exists(.attributes.logfire_trace_id) {
    trace_candidate = to_string(.attributes.logfire_trace_id) ?? ""
    if trace_candidate != "" { .trace_id = downcase(trace_candidate) }
  }
}

if !exists(.span_id) {
  if exists(.attributes.span_id) {
    span_candidate = to_string(.attributes.span_id) ?? ""
    if span_candidate != "" { .span_id = downcase(span_candidate) }
  } else if exists(.attributes."logfire.span_id") {
    span_candidate = to_string(.attributes."logfire.span_id") ?? ""
    if span_candidate != "" { .span_id = downcase(span_candidate) }
  } else if exists(.attributes.logfire_span_id) {
    span_candidate = to_string(.attributes.logfire_span_id) ?? ""
    if span_candidate != "" { .span_id = downcase(span_candidate) }
  }
}

# Preserve span name context if supplied by Logfire
if exists(.attributes."logfire.span_name") {
  .span_name = to_string(.attributes."logfire.span_name") ?? ""
}

# Capture Logfire observation identifiers when present
if exists(.attributes."logfire.observation_id") {
  .observation_id = to_string(.attributes."logfire.observation_id") ?? ""
}

# Normalize severity defaults if missing
if !exists(.severity_text) && exists(.level) {
  .severity_text = to_string(.level) ?? "INFO"
}
'''

[transforms.logs_enrich]
type = "remap"
inputs = ["logs_logfire_normalize"]
source = '''
# Enrich with metadata from resource attributes or set defaults
# Service name from resource or unknown
if exists(.resource.attributes."service.name") {
  .service = string!(.resource.attributes."service.name")
} else if exists(.attributes.service) {
  .service = string!(.attributes.service)
} else {
  .service = "unknown"
}

# Environment from resource or local
if exists(.resource.attributes.environment) {
  .environment = string!(.resource.attributes.environment)
} else if exists(.attributes.environment) {
  .environment = string!(.attributes.environment)
} else {
  .environment = "local"
}

# Application version from resource or dev
if exists(.resource.attributes."service.version") {
  .application_version = string!(.resource.attributes."service.version")
} else if exists(.attributes.application_version) {
  .application_version = string!(.attributes.application_version)
} else {
  .application_version = "dev"
}

# Ensure category field exists (default to "app")
if !exists(.attributes.category) {
  .attributes.category = "app"
}
'''

# Console output for local debugging
[sinks.logs_console]
inputs = ["logs_enrich"]
target = "stdout"
type = "console"

[sinks.logs_console.encoding]
codec = "json"

# File sink for local log persistence
[sinks.logs_file]
type = "file"
inputs = ["logs_enrich"]
path = "tmp/vector-logs.log"

[sinks.logs_file.encoding]
codec = "json"

# OpenObserve OTLP HTTP sink for production log storage
[sinks.logs_openobserve]
type = "http"
inputs = ["logs_enrich"]
uri = "${OPENOBSERVE_URL:-http://localhost:5080}/api/${OPENOBSERVE_ORG:-default}/v1/logs"
method = "post"

[sinks.logs_openobserve.encoding]
codec = "json"

[sinks.logs_openobserve.auth]
strategy = "basic"
user = "${OPENOBSERVE_USER:-root@example.com}"
password = "${OPENOBSERVE_TOKEN:-dummy-token-for-validation}"

[sinks.logs_openobserve.request]
timeout_secs = 30
retry_attempts = 3

  [sinks.logs_openobserve.request.headers]
  "Content-Type" = "application/json"
