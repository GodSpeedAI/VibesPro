name: build-matrix

on:
  push:
    branches: [main]
    tags: ['v*.*.*'] # enables optional release job
  pull_request:
    branches: [main]

permissions:
  contents: read

concurrency:
  group: build-matrix-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ---------- Prepare: cache keys & versions (Ubuntu) ----------
  prepare:
    runs-on: ubuntu-22.04
    timeout-minutes: 10
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      AQUA_GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    outputs:
      node_version: ${{ steps.vers.outputs.node }}
      python_version: ${{ steps.vers.outputs.python }}
      rust_version: ${{ steps.vers.outputs.rust }}
    steps:
      - name: Checkout
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 1

      - name: Install mise (for version introspection)
        run: |
          curl https://mise.run | bash
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          mise --version
          mise trust --yes .mise.toml

      - name: Resolve versions from .mise.toml
        id: vers
        shell: bash
        run: |
          # Emits JSON; robust against plugin formatting changes
          J=$(mise ls --json || echo '{}')
          get_version() {
            echo "$J" | jq -r --arg tool "$1" '
              (if type == "object" and has($tool) then .[$tool] else [] end)
              | map(.version)
              | first // empty
            '
          }
          echo "node=$(get_version node)"     >> $GITHUB_OUTPUT
          echo "python=$(get_version python)" >> $GITHUB_OUTPUT
          echo "rust=$(get_version rust)"     >> $GITHUB_OUTPUT

  # ---------- Build & Test Matrix ----------
  build-test:
    needs: prepare
    timeout-minutes: 45
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-22.04, macos-14]
        include:
          - os: ubuntu-22.04
            pkg_mgr: apt
          - os: macos-14
            pkg_mgr: brew
    runs-on: ${{ matrix.os }}
    env:
      MISE_NONINTERACTIVE: '1'
      # Allow building PyO3-based wheels on newer Python by using ABI3 forward
      # compatibility. This avoids build aborts when runner Python is newer than
      # PyO3's checked maximum (example: CPython 3.14 vs PyO3 0.24.1 expecting <=3.13).
      PYO3_USE_ABI3_FORWARD_COMPATIBILITY: '1'
      IS_FORK: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name != github.repository }}
      SOPS_LOADED: 'false'
      SOPS_AGE_KEY: ${{ secrets.SOPS_AGE_KEY }}
      NX_NO_CLOUD: 'true'
      NX_REJECT_REMOTE_CACHE: 'true'
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      AQUA_GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      SOPS_VERSION: '3.11.0'
      SOPS_CHECKSUM: '775f1384d55decfad228e7196a3f683791914f92a473f78fc47700531c29dfef'

    steps:
      - name: Checkout
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 1

      # ---- Base tools (age/jq) for both OSes ----
      - name: Install base packages
        shell: bash
        run: |
          if [ "${{ matrix.pkg_mgr }}" = "apt" ]; then
            sudo apt-get update
            sudo apt-get install -y --no-install-recommends age jq make
          else
            brew update
            brew install age jq
          fi

      # ---- Install just ----
      - name: Install just
        shell: bash
        run: |
          set -euo pipefail
          # Check if just is already available (e.g., via mise or pre-installed)
          if command -v just >/dev/null 2>&1; then
            echo "✅ just already available"
            just --version
            exit 0
          fi

          # Install based on OS
          if [ "${{ matrix.pkg_mgr }}" = "apt" ]; then
            echo "Installing just via official installer..."
            curl --proto '=https' --tlsv1.2 -sSf https://just.systems/install.sh | bash -s -- --to /usr/local/bin
            sudo chmod +x /usr/local/bin/just
          else
            echo "Installing just via Homebrew..."
            brew install just
          fi

          # Verify installation succeeded
          just --version

      # ---- Install SOPS ----
      - name: Install SOPS
        shell: bash
        run: |
          set -euo pipefail
          if [ "${{ matrix.os }}" = "ubuntu-22.04" ]; then
            SOPS_FILE="sops-v${SOPS_VERSION}.linux.amd64"
            # Fetch via curl and write to a temp file avoiding pipes to sudo.
            curl -fSL -o sops "https://github.com/getsops/sops/releases/download/v${SOPS_VERSION}/${SOPS_FILE}"
            sudo mv sops /usr/local/bin/sops
            sudo chmod +x /usr/local/bin/sops
          else
            brew install sops
          fi
          sops --version
          if ! sops --version | grep -q "${SOPS_VERSION}"; then
            echo "::error::Installed sops version does not match expected ${SOPS_VERSION}"
            sops --version
            exit 1
          fi

      # ---- Devbox (OS toolchain) — skip on mac if you prefer native ----
      - name: Install Devbox
        shell: bash
        run: |
          curl -fsSL https://get.jetpack.io/devbox | bash -s -- -f
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          devbox version

      # ---- mise runtimes ----
      - name: Install mise
        run: |
          curl https://mise.run | bash
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          mise --version
      - name: Trust mise config
        run: mise trust --yes .mise.toml
      - name: Cache mise runtimes
        uses: actions/cache@9255dc7a253b0ccc959486e2bca901246202afeb # v5.0.1
        with:
          path: |
            ~/.local/share/mise
            ~/.cache/mise
          # Key must be computed on the target runner OS/arch; using a key computed
          # on Ubuntu can restore Linux binaries on macOS (e.g., pnpm) and fail
          # with "cannot execute binary file" (exit 126).
          key: mise-v2-${{ runner.os }}-${{ runner.arch }}-${{ hashFiles('.mise.toml') }}
          restore-keys: |
            mise-v2-${{ runner.os }}-${{ runner.arch }}-

      - name: Install runtimes (Node/Python/Rust via mise)
        run: |
          mise install
          # Add mise shims to PATH for all subsequent steps
          echo "$HOME/.local/share/mise/shims" >> $GITHUB_PATH
          mise reshim

      - name: Ensure pinned Rust toolchain
        shell: bash
        run: |
          set -euo pipefail
          # Install rustup if missing
          if ! command -v rustup > /dev/null 2>&1; then
            curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
            # Source cargo env - this is expected to fail in some shells
            if [[ -f "$HOME/.cargo/env" ]]; then
              source "$HOME/.cargo/env"
            fi
          fi
          # Install clippy and rustfmt for the mise-managed stable toolchain
          rustup component add clippy rustfmt
          # Also install nightly for any nightly-specific needs
          rustup toolchain install nightly-2025-11-01 --no-self-update --component clippy,rustfmt

      # ---- Node package manager (pnpm managed by mise, skip corepack) ----
      # pnpm is now installed via mise to avoid Node corruption issues

      - name: Cache pnpm store (optional)
        if: hashFiles('pnpm-lock.yaml') != ''
        uses: actions/cache@9255dc7a253b0ccc959486e2bca901246202afeb # v5.0.1
        with:
          path: |
            ~/.pnpm-store
          key: pnpm-${{ runner.os }}-${{ hashFiles('pnpm-lock.yaml') }}
          restore-keys: |
            pnpm-${{ runner.os }}-

      # ---- Secrets (Minimal CI: no direnv) ----
      # If your unit tests/build need secrets, decrypt them. If not, you can remove this step.
      # ---- Secrets (Minimal CI: no direnv) ----
      # If your unit tests/build need secrets, decrypt them. If not, step will be skipped.
      - name: Decrypt secrets to ephemeral env (if SOPS_AGE_KEY secret provided)
        id: sops
        if: ${{ env.IS_FORK != 'true' }}
        run: |
          # Attempt decryption only when secret is set and file exists.
          if [ -n "$SOPS_AGE_KEY" ] && [ -f .secrets.env.sops ]; then
            echo "SOPS_AGE_KEY appears set; attempting decryption..."
            sops --input-type dotenv --output-type dotenv -d .secrets.env.sops > /tmp/ci.env
            # Delegate parsing and safe GITHUB_ENV writes to a helper script
            bash ./scripts/ci/decrypt-ci-env.sh /tmp/ci.env
            echo "loaded=true" >> $GITHUB_OUTPUT
          else
            echo "SOPS_AGE_KEY not set or .secrets.env.sops missing; skipping decryption."
            echo "loaded=false" >> $GITHUB_OUTPUT
          fi

      # When secret not provided, explicitly mark loaded=false (so downstream steps can detect absence)
      - name: (noop) Ensure sops step produced an output
        run: |
          # The prior step sets steps.sops.outputs.loaded; if not present default to false
          if [ -z "${{ steps.sops.outputs.loaded }}" ]; then
            echo "loaded=false" >> $GITHUB_OUTPUT
          fi

      # ---- SOPS status: unify the loaded flag for downstream steps ----
      # This step always runs and emits a stable step output and an env var so
      # subsequent steps can reliably detect whether secrets were loaded.
      - name: SOPS status
        id: sops_status
        run: |
          if [ -f /tmp/ci.env ]; then
            echo "loaded=true" >> $GITHUB_OUTPUT
            echo "SOPS_LOADED=true" >> $GITHUB_ENV
          else
            echo "loaded=false" >> $GITHUB_OUTPUT
            echo "SOPS_LOADED=false" >> $GITHUB_ENV
          fi

      # ---- Job-level guard: fail early if secrets are required but not provided ----
      - name: Enforce required secrets
        run: |
          # GitHub injects repository secrets into runner environment as env vars (if configured).
          if [ "$REQUIRE_SOPS_SECRETS" = 'true' ] && [ "${{ steps.sops_status.outputs.loaded }}" != 'true' ]; then
            echo "Required secrets are not available (REQUIRE_SOPS_SECRETS=true but SOPS not loaded)."
            exit 1
          else
            echo "Secrets requirement satisfied or not required."
          fi

      # ---- Volta compatibility & enforcement (CI does not install Volta) ----
      - name: Verify Node pins (mise vs Volta)
        run: just verify-node

      # ---- Install project dependencies (explicit conditional steps) ----
      # Each step only runs when its lock/config file exists, and failures are not masked

      - name: Install Node dependencies (pnpm)
        if: hashFiles('pnpm-lock.yaml') != ''
        run: pnpm install --frozen-lockfile

      - name: Install uv (Python tool manager)
        # Use astral-sh/setup-uv action to install uv on runner so `uv` is available.
        uses: astral-sh/setup-uv@681c641aba71e4a1c380be3ab5e12ad51f415867

      - name: Install Python dependencies (uv)
        if: hashFiles('uv.lock') != '' || hashFiles('pyproject.toml') != ''
        run: |
          # Ensure PyO3 ABI3 forward compatibility is enabled for native builds
          # This helps when runner Python is newer than PyO3's max supported version.
          export PYO3_USE_ABI3_FORWARD_COMPATIBILITY=1
          uv sync --frozen

      - name: Fetch Rust dependencies (cargo)
        if: hashFiles('Cargo.toml') != ''
        run: cargo fetch

      # ---- Build / Lint / Test ----
      - name: Lint
        run: |
          set -euo pipefail
          LINT_FAILED=false

          if [ -f package.json ]; then
            echo "Running ESLint..."
            if ! pnpm run lint; then
              echo "::error::ESLint failed"
              LINT_FAILED=true
            fi
          fi

          if [ -f pyproject.toml ]; then
            echo "Running Python linters..."
            if ! just lint-python; then
              echo "::error::Python lint failed"
              LINT_FAILED=true
            fi
          fi

          if [ -f Cargo.toml ]; then
            echo "Running Clippy..."
            if ! cargo clippy --all-targets -- -D warnings; then
              echo "::error::Clippy failed"
              LINT_FAILED=true
            fi
          fi

          if [ "$LINT_FAILED" = "true" ]; then
            echo "::error::One or more lint checks failed"
            exit 1
          fi

      - name: Build
        run: just build

      - name: Test
        run: just test

      # ---- Coverage & Artifacts ----
      - name: Collect coverage (if any)
        run: |
          mkdir -p artifacts/coverage
          # Add your coverage copy/move commands here, e.g.:
          # cp -r coverage/ artifacts/coverage/ || true
          # cp coverage.xml artifacts/coverage/ || true
        if: always()

      - name: Upload artifacts (logs/coverage/build)
        if: always()
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: build-${{ matrix.os }}-${{ github.sha }}
          path: |
            artifacts/**
            dist/**
            build/**
            coverage/**
            **/junit*.xml

      - name: Cleanup secrets
        if: always()
        run: rm -f /tmp/ci.env

  # ---------- Optional Release (tagged builds) ----------
  release:
    if: startsWith(github.ref, 'refs/tags/v')
    needs: [prepare, build-test]
    runs-on: ubuntu-22.04
    timeout-minutes: 30
    env:
      MISE_NONINTERACTIVE: '1'
      SOPS_AGE_KEY: ${{ secrets.SOPS_AGE_KEY }}
      NX_NO_CLOUD: 'true'
      NX_REJECT_REMOTE_CACHE: 'true'
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      AQUA_GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      SOPS_VERSION: '3.11.0'
      SOPS_CHECKSUM: '775f1384d55decfad228e7196a3f683791914f92a473f78fc47700531c29dfef'
    steps:
      - name: Checkout
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 1

      - name: Install base packages
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends age jq make

      - name: Install SOPS
        run: |
          set -euo pipefail
          SOPS_FILE="sops-v${SOPS_VERSION}.linux.amd64"
          curl -fSL -o sops "https://github.com/getsops/sops/releases/download/v${SOPS_VERSION}/${SOPS_FILE}"
          echo "${SOPS_CHECKSUM}  sops" | sha256sum -c -
          sudo mv sops /usr/local/bin/sops
          sudo chmod +x /usr/local/bin/sops
          sops --version
          if ! sops --version | grep -q "${SOPS_VERSION}"; then
            echo "::error::Installed sops version does not match expected ${SOPS_VERSION}"
            sops --version
            exit 1
          fi

      - name: Install Devbox
        run: |
          curl -fsSL https://get.jetpack.io/devbox | bash -s -- -f
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          devbox version

      - name: Install mise
        run: |
          curl https://mise.run | bash
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          mise --version
          mise trust --yes .mise.toml

      - name: Setup runtimes
        run: |
          mise install
          # Add mise shims to PATH for all subsequent steps
          echo "$HOME/.local/share/mise/shims" >> $GITHUB_PATH
          mise reshim

      - name: Decrypt release secrets (if provided)
        run: |
          if [ -n "$SOPS_AGE_KEY" ] && [ -f .secrets.env.sops ]; then
            echo "SOPS_AGE_KEY present; decrypting release secrets"
            sops --input-type dotenv --output-type dotenv -d .secrets.env.sops > /tmp/ci.env
            # Use shared decrypt script to parse and write secrets into GITHUB_ENV
            bash ./scripts/ci/decrypt-ci-env.sh /tmp/ci.env
          else
            echo "No SOPS_AGE_KEY provided or .secrets.env.sops missing; skipping release secret decryption"
          fi

      - name: Build (release)
        run: just build

      # Example: npm publish / docker push (uncomment & tailor)
      # - name: Publish package
      #   env:
      #     NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
      #   run: |
      #     echo "//registry.npmjs.org/:_authToken=${NPM_TOKEN}" > ~/.npmrc
      #     pnpm publish --access public --no-git-checks

      # - name: Push Docker image
      #   env:
      #     REGISTRY: ghcr.io
      #     IMAGE: ${{ github.repository }}
      #     GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      #   run: |
      #     echo "${GH_TOKEN}" | docker login ghcr.io -u $ --password-stdin
      #     docker build -t ${REGISTRY}/${IMAGE}:${GITHUB_REF_NAME} .
      #     docker push ${REGISTRY}/${IMAGE}:${GITHUB_REF_NAME}

      - name: Cleanup secrets
        if: always()
        run: rm -f /tmp/ci.env
