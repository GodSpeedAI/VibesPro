name: build-matrix

on:
  push:
    branches: [main]
    tags: ["v*.*.*"] # enables the optional release job
  pull_request:
    branches: [main]

permissions:
  contents: read

concurrency:
  group: build-matrix-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ---------- Prepare: cache keys & versions (Ubuntu) ----------
  prepare:
    runs-on: ubuntu-latest
    outputs:
      mise_cache_key: ${{ steps.cache-key.outputs.mise_cache_key }}
      node_version: ${{ steps.vers.outputs.node }}
      python_version: ${{ steps.vers.outputs.python }}
      rust_version: ${{ steps.vers.outputs.rust }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install mise (for version introspection)
        run: |
          curl https://mise.run | bash
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          mise --version

      - name: Resolve versions from .mise.toml
        id: vers
        shell: bash
        run: |
          # Emits JSON; robust against plugin formatting changes
          J=$(mise ls --json || echo '{}')
          get_version() {
            echo "$J" | jq -r --arg tool "$1" '
              (if type == "object" and has($tool) then .[$tool] else [] end)
              | map(.version)
              | first // empty
            '
          }
          echo "node=$(get_version node)"     >> $GITHUB_OUTPUT
          echo "python=$(get_version python)" >> $GITHUB_OUTPUT
          echo "rust=$(get_version rust)"     >> $GITHUB_OUTPUT

      - name: Compute mise cache key
        id: cache-key
        run: |
          echo "mise_cache_key=mise-${{ runner.os }}-${{ hashFiles('.mise.toml') }}" >> $GITHUB_OUTPUT

  # ---------- Build & Test Matrix ----------
  build-test:
    needs: prepare
    strategy:
      fail-fast: false
      matrix:
        # Temporarily restrict to ubuntu-latest to avoid macOS native build failures
        os: [ubuntu-latest]
        include:
          - os: ubuntu-latest
            pkg_mgr: apt
    runs-on: ${{ matrix.os }}
    env:
      MISE_NONINTERACTIVE: "1"
      # Allow building PyO3-based wheels on newer Python by using ABI3 forward
      # compatibility. This avoids build aborts when runner Python is newer than
      # PyO3's checked maximum (example: CPython 3.14 vs PyO3 0.24.1 expecting <=3.13).
      PYO3_USE_ABI3_FORWARD_COMPATIBILITY: "1"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # ---- Base tools (age/jq) for both OSes ----
      - name: Install base packages
        shell: bash
        run: |
          if [ "${{ matrix.pkg_mgr }}" = "apt" ]; then
            sudo apt-get update
            sudo apt-get install -y --no-install-recommends age jq make
          else
            brew update
            brew install age jq
          fi

      # ---- Install just ----
      - name: Install just
        shell: bash
        run: |
          # Try the official installer, fallback to apt when installer fails or is blocked
          if [ "${{ matrix.pkg_mgr }}" = "apt" ]; then
            set -euo pipefail
            if curl --proto '=https' --tlsv1.2 -sSf https://just.systems/install.sh | bash -s -- --to /usr/local/bin; then
              sudo chmod +x /usr/local/bin/just
            else
              echo "just installer failed; attempting apt fallback"
              sudo apt-get update || true
              sudo apt-get install -y just || echo "could not install just; continuing without just"
            fi
          else
            brew install just || true
          fi
          just --version || true

      # ---- Install SOPS ----
      - name: Install SOPS
        shell: bash
        run: |
          SOPS_VERSION="3.9.3"
          if [ "${{ matrix.os }}" = "ubuntu-latest" ]; then
            curl -LO "https://github.com/getsops/sops/releases/download/v${SOPS_VERSION}/sops-v${SOPS_VERSION}.linux.amd64"
            sudo mv "sops-v${SOPS_VERSION}.linux.amd64" /usr/local/bin/sops
            sudo chmod +x /usr/local/bin/sops
          else
            brew install sops
          fi
          sops --version

      # ---- Devbox (OS toolchain) â€” skip on mac if you prefer native ----
      - name: Install Devbox
        shell: bash
        run: |
          curl -fsSL https://get.jetpack.io/devbox | bash -s -- -f
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          devbox version

      # ---- mise runtimes ----
      - name: Install mise
        run: |
          curl https://mise.run | bash
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          mise --version
      - name: Trust mise config
        run: mise trust --yes .mise.toml
      - name: Cache mise runtimes
        uses: actions/cache@v4
        with:
          path: |
            ~/.local/share/mise
            ~/.cache/mise
          key: ${{ needs.prepare.outputs.mise_cache_key }}
          restore-keys: |
            mise-${{ runner.os }}-
      - name: Install runtimes (Node/Python/Rust via mise)
        run: mise install

      # ---- Node package manager (optional; respects Corepack) ----
      - name: Enable corepack (optional)
        run: corepack enable

      - name: Cache pnpm store (optional)
        if: hashFiles('pnpm-lock.yaml') != ''
        uses: actions/cache@v4
        with:
          path: ~/.pnpm-store
          key: pnpm-${{ runner.os }}-${{ hashFiles('pnpm-lock.yaml') }}
          restore-keys: |
            pnpm-${{ runner.os }}-

      # ---- Secrets (Minimal CI: no direnv) ----
      # If your unit tests/build need secrets, decrypt them. If not, you can remove this step.
      # ---- Secrets (Minimal CI: no direnv) ----
      # If your unit tests/build need secrets, decrypt them. If not, the step will be skipped.
      - name: Decrypt secrets to ephemeral env (if SOPS_AGE_KEY secret provided)
        id: sops
        run: |
          # Attempt decryption only when the secret is set and the file exists.
          if [ -n "$SOPS_AGE_KEY" ] && [ -f .secrets.env.sops ]; then
            echo "SOPS_AGE_KEY appears set; attempting decryption..."
            sops --input-type dotenv --output-type dotenv -d .secrets.env.sops > /tmp/ci.env
            set -a; source /tmp/ci.env; set +a
            echo "loaded=true" >> $GITHUB_OUTPUT
          else
            echo "SOPS_AGE_KEY not set or .secrets.env.sops missing; skipping decryption."
            echo "loaded=false" >> $GITHUB_OUTPUT
          fi

      # When secret not provided, explicitly mark loaded=false (so downstream steps can detect absence)
      - name: (noop) Ensure sops step produced an output
        run: |
          # The prior step sets steps.sops.outputs.loaded; if not present default to false
          if [ -z "${{ steps.sops.outputs.loaded }}" ]; then
            echo "loaded=false" >> $GITHUB_OUTPUT
          fi

      # ---- SOPS status: unify the loaded flag for downstream steps ----
      # This step always runs and emits a stable step output and an env var so
      # subsequent steps can reliably detect whether secrets were loaded.
      - name: SOPS status
        id: sops_status
        run: |
          if [ -f /tmp/ci.env ]; then
            echo "loaded=true" >> $GITHUB_OUTPUT
            echo "SOPS_LOADED=true" >> $GITHUB_ENV
          else
            echo "loaded=false" >> $GITHUB_OUTPUT
            echo "SOPS_LOADED=false" >> $GITHUB_ENV
          fi

      # ---- Job-level guard: fail early if secrets are required but not provided ----
      - name: Enforce required secrets
        run: |
          # GitHub injects repository secrets into runner environment as env vars (if configured).
          if [ "$REQUIRE_SOPS_SECRETS" = 'true' ] && [ "${{ steps.sops_status.outputs.loaded }}" != 'true' ]; then
            echo "Required secrets are not available (REQUIRE_SOPS_SECRETS=true but SOPS not loaded)."
            exit 1
          else
            echo "Secrets requirement satisfied or not required."
          fi

      # ---- Volta compatibility & enforcement (CI does not install Volta) ----
      - name: Verify Node pins (mise vs Volta)
        run: just verify-node

      # ---- Install project dependencies (explicit conditional steps) ----
      # Each step only runs when its lock/config file exists, and failures are not masked

      - name: Install Node dependencies (pnpm)
        if: hashFiles('pnpm-lock.yaml') != ''
        run: pnpm install --frozen-lockfile

      - name: Install uv (Python tool manager)
        # Use the astral-sh/setup-uv action to install uv on the runner so `uv` is available.
        uses: astral-sh/setup-uv@6dfebec6ddbcd197e02256fbdf54deb334fb7f06

      - name: Install Python dependencies (uv)
        if: hashFiles('uv.lock') != '' || hashFiles('pyproject.toml') != ''
        run: |
          # Ensure PyO3 ABI3 forward compatibility is enabled for native builds
          # This helps when runner Python is newer than PyO3's max supported version.
          export PYO3_USE_ABI3_FORWARD_COMPATIBILITY=1
          uv sync --frozen

      - name: Fetch Rust dependencies (cargo)
        if: hashFiles('Cargo.toml') != ''
        run: cargo fetch

      # ---- Build / Lint / Test ----
      - name: Lint
        run: |
          if [ -f package.json ]; then pnpm run lint || pnpm run lint:ci || true; fi
          if [ -f pyproject.toml ]; then just lint-python || true; fi
          if [ -f Cargo.toml ]; then cargo clippy --all-targets -- -D warnings || true; fi

      - name: Build
        run: just build

      - name: Test
        run: just test

      # ---- Coverage & Artifacts ----
      - name: Collect coverage (if any)
        run: |
          mkdir -p artifacts/coverage
          # Add your coverage copy/move commands here, e.g.:
          # cp -r coverage/ artifacts/coverage/ || true
          # cp coverage.xml artifacts/coverage/ || true
        if: always()

      - name: Upload artifacts (logs/coverage/build)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-${{ matrix.os }}-${{ github.sha }}
          path: |
            artifacts/**
            dist/**
            build/**
            coverage/**
            **/junit*.xml

      - name: Cleanup secrets
        if: always()
        run: rm -f /tmp/ci.env

  # ---------- Optional Release (tagged builds) ----------
  release:
    if: startsWith(github.ref, 'refs/tags/v')
    needs: [prepare, build-test]
    runs-on: ubuntu-latest
    env:
      MISE_NONINTERACTIVE: "1"
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install base packages
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends age jq make

      - name: Install SOPS
        run: |
          SOPS_VERSION="3.9.3"
          curl -LO "https://github.com/getsops/sops/releases/download/v${SOPS_VERSION}/sops-v${SOPS_VERSION}.linux.amd64"
          sudo mv "sops-v${SOPS_VERSION}.linux.amd64" /usr/local/bin/sops
          sudo chmod +x /usr/local/bin/sops
          sops --version

      - name: Install Devbox
        run: |
          curl -fsSL https://get.jetpack.io/devbox | bash -s -- -f
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Install mise
        run: |
          curl https://mise.run | bash
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Setup runtimes
        run: mise install

      - name: Decrypt release secrets (if provided)
        run: |
          if [ -n "$SOPS_AGE_KEY" ] && [ -f .secrets.env.sops ]; then
            echo "SOPS_AGE_KEY present; decrypting release secrets"
            sops --input-type dotenv --output-type dotenv -d .secrets.env.sops > /tmp/ci.env
            set -a; source /tmp/ci.env; set +a
            # Export to GITHUB_ENV for subsequent steps
            cat /tmp/ci.env >> $GITHUB_ENV
          else
            echo "No SOPS_AGE_KEY provided or .secrets.env.sops missing; skipping release secret decryption"
          fi

      - name: Build (release)
        run: just build

      # Example: npm publish / docker push (uncomment & tailor)
      # - name: Publish package
      #   env:
      #     NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
      #   run: |
      #     echo "//registry.npmjs.org/:_authToken=${NPM_TOKEN}" > ~/.npmrc
      #     pnpm publish --access public --no-git-checks

      # - name: Push Docker image
      #   env:
      #     REGISTRY: ghcr.io
      #     IMAGE: ${{ github.repository }}
      #     GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      #   run: |
      #     echo "${GH_TOKEN}" | docker login ghcr.io -u $ --password-stdin
      #     docker build -t ${REGISTRY}/${IMAGE}:${GITHUB_REF_NAME} .
      #     docker push ${REGISTRY}/${IMAGE}:${GITHUB_REF_NAME}

      - name: Cleanup secrets
        if: always()
        run: rm -f /tmp/ci.env
